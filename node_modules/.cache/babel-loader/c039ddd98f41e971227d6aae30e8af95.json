{"ast":null,"code":"// drag\n(function (window, factory) {\n  // universal module definition\n  if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, require('./core'), require('unidragger'), require('fizzy-ui-utils'));\n  } else {\n    // browser global\n    window.Flickity = factory(window, window.Flickity, window.Unidragger, window.fizzyUIUtils);\n  }\n})(typeof window != 'undefined' ? window : this, function factory(window, Flickity, Unidragger, utils) {\n  // ----- defaults ----- //\n  Object.assign(Flickity.defaults, {\n    draggable: '>1',\n    dragThreshold: 3\n  }); // -------------------------- drag prototype -------------------------- //\n\n  let proto = Flickity.prototype;\n  Object.assign(proto, Unidragger.prototype); // inherit Unidragger\n\n  proto.touchActionValue = ''; // --------------------------  -------------------------- //\n\n  Flickity.create.drag = function () {\n    this.on('activate', this.onActivateDrag);\n    this.on('uiChange', this._uiChangeDrag);\n    this.on('deactivate', this.onDeactivateDrag);\n    this.on('cellChange', this.updateDraggable);\n    this.on('pointerDown', this.handlePointerDown);\n    this.on('pointerUp', this.handlePointerUp);\n    this.on('pointerDown', this.handlePointerDone);\n    this.on('dragStart', this.handleDragStart);\n    this.on('dragMove', this.handleDragMove);\n    this.on('dragEnd', this.handleDragEnd);\n    this.on('staticClick', this.handleStaticClick); // TODO updateDraggable on resize? if groupCells & slides change\n  };\n\n  proto.onActivateDrag = function () {\n    this.handles = [this.viewport];\n    this.bindHandles();\n    this.updateDraggable();\n  };\n\n  proto.onDeactivateDrag = function () {\n    this.unbindHandles();\n    this.element.classList.remove('is-draggable');\n  };\n\n  proto.updateDraggable = function () {\n    // disable dragging if less than 2 slides. #278\n    if (this.options.draggable === '>1') {\n      this.isDraggable = this.slides.length > 1;\n    } else {\n      this.isDraggable = this.options.draggable;\n    }\n\n    this.element.classList.toggle('is-draggable', this.isDraggable);\n  };\n\n  proto._uiChangeDrag = function () {\n    delete this.isFreeScrolling;\n  }; // -------------------------- pointer events -------------------------- //\n\n\n  proto.handlePointerDown = function (event) {\n    if (!this.isDraggable) {\n      // proceed for staticClick\n      this.bindActivePointerEvents(event);\n      return;\n    }\n\n    let isTouchStart = event.type === 'touchstart';\n    let isTouchPointer = event.pointerType === 'touch';\n    let isFocusNode = event.target.matches('input, textarea, select');\n    if (!isTouchStart && !isTouchPointer && !isFocusNode) event.preventDefault();\n    if (!isFocusNode) this.focus(); // blur\n\n    if (document.activeElement !== this.element) document.activeElement.blur(); // stop if it was moving\n\n    this.dragX = this.x;\n    this.viewport.classList.add('is-pointer-down'); // track scrolling\n\n    this.pointerDownScroll = getScrollPosition();\n    window.addEventListener('scroll', this);\n    this.bindActivePointerEvents(event);\n  }; // ----- move ----- //\n\n\n  proto.hasDragStarted = function (moveVector) {\n    return Math.abs(moveVector.x) > this.options.dragThreshold;\n  }; // ----- up ----- //\n\n\n  proto.handlePointerUp = function () {\n    delete this.isTouchScrolling;\n    this.viewport.classList.remove('is-pointer-down');\n  };\n\n  proto.handlePointerDone = function () {\n    window.removeEventListener('scroll', this);\n    delete this.pointerDownScroll;\n  }; // -------------------------- dragging -------------------------- //\n\n\n  proto.handleDragStart = function () {\n    if (!this.isDraggable) return;\n    this.dragStartPosition = this.x;\n    this.startAnimation();\n    window.removeEventListener('scroll', this);\n  };\n\n  proto.handleDragMove = function (event, pointer, moveVector) {\n    if (!this.isDraggable) return;\n    event.preventDefault();\n    this.previousDragX = this.dragX; // reverse if right-to-left\n\n    let direction = this.options.rightToLeft ? -1 : 1; // wrap around move. #589\n\n    if (this.isWrapping) moveVector.x %= this.slideableWidth;\n    let dragX = this.dragStartPosition + moveVector.x * direction;\n\n    if (!this.isWrapping) {\n      // slow drag\n      let originBound = Math.max(-this.slides[0].target, this.dragStartPosition);\n      dragX = dragX > originBound ? (dragX + originBound) * 0.5 : dragX;\n      let endBound = Math.min(-this.getLastSlide().target, this.dragStartPosition);\n      dragX = dragX < endBound ? (dragX + endBound) * 0.5 : dragX;\n    }\n\n    this.dragX = dragX;\n    this.dragMoveTime = new Date();\n  };\n\n  proto.handleDragEnd = function () {\n    if (!this.isDraggable) return;\n    let {\n      freeScroll\n    } = this.options;\n    if (freeScroll) this.isFreeScrolling = true; // set selectedIndex based on where flick will end up\n\n    let index = this.dragEndRestingSelect();\n\n    if (freeScroll && !this.isWrapping) {\n      // if free-scroll & not wrap around\n      // do not free-scroll if going outside of bounding slides\n      // so bounding slides can attract slider, and keep it in bounds\n      let restingX = this.getRestingPosition();\n      this.isFreeScrolling = -restingX > this.slides[0].target && -restingX < this.getLastSlide().target;\n    } else if (!freeScroll && index === this.selectedIndex) {\n      // boost selection if selected index has not changed\n      index += this.dragEndBoostSelect();\n    }\n\n    delete this.previousDragX; // apply selection\n    // HACK, set flag so dragging stays in correct direction\n\n    this.isDragSelect = this.isWrapping;\n    this.select(index);\n    delete this.isDragSelect;\n  };\n\n  proto.dragEndRestingSelect = function () {\n    let restingX = this.getRestingPosition(); // how far away from selected slide\n\n    let distance = Math.abs(this.getSlideDistance(-restingX, this.selectedIndex)); // get closet resting going up and going down\n\n    let positiveResting = this._getClosestResting(restingX, distance, 1);\n\n    let negativeResting = this._getClosestResting(restingX, distance, -1); // use closer resting for wrap-around\n\n\n    return positiveResting.distance < negativeResting.distance ? positiveResting.index : negativeResting.index;\n  };\n  /**\n   * given resting X and distance to selected cell\n   * get the distance and index of the closest cell\n   * @param {Number} restingX - estimated post-flick resting position\n   * @param {Number} distance - distance to selected cell\n   * @param {Integer} increment - +1 or -1, going up or down\n   * @returns {Object} - { distance: {Number}, index: {Integer} }\n   */\n\n\n  proto._getClosestResting = function (restingX, distance, increment) {\n    let index = this.selectedIndex;\n    let minDistance = Infinity;\n    let condition = this.options.contain && !this.isWrapping ? // if containing, keep going if distance is equal to minDistance\n    (dist, minDist) => dist <= minDist : (dist, minDist) => dist < minDist;\n\n    while (condition(distance, minDistance)) {\n      // measure distance to next cell\n      index += increment;\n      minDistance = distance;\n      distance = this.getSlideDistance(-restingX, index);\n      if (distance === null) break;\n      distance = Math.abs(distance);\n    }\n\n    return {\n      distance: minDistance,\n      // selected was previous index\n      index: index - increment\n    };\n  };\n  /**\n   * measure distance between x and a slide target\n   * @param {Number} x - horizontal position\n   * @param {Integer} index - slide index\n   * @returns {Number} - slide distance\n   */\n\n\n  proto.getSlideDistance = function (x, index) {\n    let len = this.slides.length; // wrap around if at least 2 slides\n\n    let isWrapAround = this.options.wrapAround && len > 1;\n    let slideIndex = isWrapAround ? utils.modulo(index, len) : index;\n    let slide = this.slides[slideIndex];\n    if (!slide) return null; // add distance for wrap-around slides\n\n    let wrap = isWrapAround ? this.slideableWidth * Math.floor(index / len) : 0;\n    return x - (slide.target + wrap);\n  };\n\n  proto.dragEndBoostSelect = function () {\n    // do not boost if no previousDragX or dragMoveTime\n    if (this.previousDragX === undefined || !this.dragMoveTime || // or if drag was held for 100 ms\n    new Date() - this.dragMoveTime > 100) {\n      return 0;\n    }\n\n    let distance = this.getSlideDistance(-this.dragX, this.selectedIndex);\n    let delta = this.previousDragX - this.dragX;\n\n    if (distance > 0 && delta > 0) {\n      // boost to next if moving towards the right, and positive velocity\n      return 1;\n    } else if (distance < 0 && delta < 0) {\n      // boost to previous if moving towards the left, and negative velocity\n      return -1;\n    }\n\n    return 0;\n  }; // ----- scroll ----- //\n\n\n  proto.onscroll = function () {\n    let scroll = getScrollPosition();\n    let scrollMoveX = this.pointerDownScroll.x - scroll.x;\n    let scrollMoveY = this.pointerDownScroll.y - scroll.y; // cancel click/tap if scroll is too much\n\n    if (Math.abs(scrollMoveX) > 3 || Math.abs(scrollMoveY) > 3) {\n      this.pointerDone();\n    }\n  }; // ----- utils ----- //\n\n\n  function getScrollPosition() {\n    return {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  } // -----  ----- //\n\n\n  return Flickity;\n});","map":{"version":3,"names":["window","factory","module","exports","require","Flickity","Unidragger","fizzyUIUtils","utils","Object","assign","defaults","draggable","dragThreshold","proto","prototype","touchActionValue","create","drag","on","onActivateDrag","_uiChangeDrag","onDeactivateDrag","updateDraggable","handlePointerDown","handlePointerUp","handlePointerDone","handleDragStart","handleDragMove","handleDragEnd","handleStaticClick","handles","viewport","bindHandles","unbindHandles","element","classList","remove","options","isDraggable","slides","length","toggle","isFreeScrolling","event","bindActivePointerEvents","isTouchStart","type","isTouchPointer","pointerType","isFocusNode","target","matches","preventDefault","focus","document","activeElement","blur","dragX","x","add","pointerDownScroll","getScrollPosition","addEventListener","hasDragStarted","moveVector","Math","abs","isTouchScrolling","removeEventListener","dragStartPosition","startAnimation","pointer","previousDragX","direction","rightToLeft","isWrapping","slideableWidth","originBound","max","endBound","min","getLastSlide","dragMoveTime","Date","freeScroll","index","dragEndRestingSelect","restingX","getRestingPosition","selectedIndex","dragEndBoostSelect","isDragSelect","select","distance","getSlideDistance","positiveResting","_getClosestResting","negativeResting","increment","minDistance","Infinity","condition","contain","dist","minDist","len","isWrapAround","wrapAround","slideIndex","modulo","slide","wrap","floor","undefined","delta","onscroll","scroll","scrollMoveX","scrollMoveY","y","pointerDone","pageXOffset","pageYOffset"],"sources":["/Users/mac/Desktop/Darasimi files/Online-Mini-Store-REST-API-x-Reactjs-/frontend/node_modules/flickity/js/drag.js"],"sourcesContent":["// drag\n( function( window, factory ) {\n  // universal module definition\n  if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n        window,\n        require('./core'),\n        require('unidragger'),\n        require('fizzy-ui-utils'),\n    );\n  } else {\n    // browser global\n    window.Flickity = factory(\n        window,\n        window.Flickity,\n        window.Unidragger,\n        window.fizzyUIUtils,\n    );\n  }\n\n}( typeof window != 'undefined' ? window : this,\n    function factory( window, Flickity, Unidragger, utils ) {\n\n// ----- defaults ----- //\n\nObject.assign( Flickity.defaults, {\n  draggable: '>1',\n  dragThreshold: 3,\n} );\n\n// -------------------------- drag prototype -------------------------- //\n\nlet proto = Flickity.prototype;\nObject.assign( proto, Unidragger.prototype ); // inherit Unidragger\nproto.touchActionValue = '';\n\n// --------------------------  -------------------------- //\n\nFlickity.create.drag = function() {\n  this.on( 'activate', this.onActivateDrag );\n  this.on( 'uiChange', this._uiChangeDrag );\n  this.on( 'deactivate', this.onDeactivateDrag );\n  this.on( 'cellChange', this.updateDraggable );\n  this.on( 'pointerDown', this.handlePointerDown );\n  this.on( 'pointerUp', this.handlePointerUp );\n  this.on( 'pointerDown', this.handlePointerDone );\n  this.on( 'dragStart', this.handleDragStart );\n  this.on( 'dragMove', this.handleDragMove );\n  this.on( 'dragEnd', this.handleDragEnd );\n  this.on( 'staticClick', this.handleStaticClick );\n  // TODO updateDraggable on resize? if groupCells & slides change\n};\n\nproto.onActivateDrag = function() {\n  this.handles = [ this.viewport ];\n  this.bindHandles();\n  this.updateDraggable();\n};\n\nproto.onDeactivateDrag = function() {\n  this.unbindHandles();\n  this.element.classList.remove('is-draggable');\n};\n\nproto.updateDraggable = function() {\n  // disable dragging if less than 2 slides. #278\n  if ( this.options.draggable === '>1' ) {\n    this.isDraggable = this.slides.length > 1;\n  } else {\n    this.isDraggable = this.options.draggable;\n  }\n  this.element.classList.toggle( 'is-draggable', this.isDraggable );\n};\n\nproto._uiChangeDrag = function() {\n  delete this.isFreeScrolling;\n};\n\n// -------------------------- pointer events -------------------------- //\n\nproto.handlePointerDown = function( event ) {\n  if ( !this.isDraggable ) {\n    // proceed for staticClick\n    this.bindActivePointerEvents( event );\n    return;\n  }\n\n  let isTouchStart = event.type === 'touchstart';\n  let isTouchPointer = event.pointerType === 'touch';\n  let isFocusNode = event.target.matches('input, textarea, select');\n  if ( !isTouchStart && !isTouchPointer && !isFocusNode ) event.preventDefault();\n  if ( !isFocusNode ) this.focus();\n  // blur\n  if ( document.activeElement !== this.element ) document.activeElement.blur();\n  // stop if it was moving\n  this.dragX = this.x;\n  this.viewport.classList.add('is-pointer-down');\n  // track scrolling\n  this.pointerDownScroll = getScrollPosition();\n  window.addEventListener( 'scroll', this );\n  this.bindActivePointerEvents( event );\n};\n\n// ----- move ----- //\n\nproto.hasDragStarted = function( moveVector ) {\n  return Math.abs( moveVector.x ) > this.options.dragThreshold;\n};\n\n// ----- up ----- //\n\nproto.handlePointerUp = function() {\n  delete this.isTouchScrolling;\n  this.viewport.classList.remove('is-pointer-down');\n};\n\nproto.handlePointerDone = function() {\n  window.removeEventListener( 'scroll', this );\n  delete this.pointerDownScroll;\n};\n\n// -------------------------- dragging -------------------------- //\n\nproto.handleDragStart = function() {\n  if ( !this.isDraggable ) return;\n\n  this.dragStartPosition = this.x;\n  this.startAnimation();\n  window.removeEventListener( 'scroll', this );\n};\n\nproto.handleDragMove = function( event, pointer, moveVector ) {\n  if ( !this.isDraggable ) return;\n\n  event.preventDefault();\n\n  this.previousDragX = this.dragX;\n  // reverse if right-to-left\n  let direction = this.options.rightToLeft ? -1 : 1;\n  // wrap around move. #589\n  if ( this.isWrapping ) moveVector.x %= this.slideableWidth;\n  let dragX = this.dragStartPosition + moveVector.x * direction;\n\n  if ( !this.isWrapping ) {\n    // slow drag\n    let originBound = Math.max( -this.slides[0].target, this.dragStartPosition );\n    dragX = dragX > originBound ? ( dragX + originBound ) * 0.5 : dragX;\n    let endBound = Math.min( -this.getLastSlide().target, this.dragStartPosition );\n    dragX = dragX < endBound ? ( dragX + endBound ) * 0.5 : dragX;\n  }\n\n  this.dragX = dragX;\n  this.dragMoveTime = new Date();\n};\n\nproto.handleDragEnd = function() {\n  if ( !this.isDraggable ) return;\n\n  let { freeScroll } = this.options;\n  if ( freeScroll ) this.isFreeScrolling = true;\n  // set selectedIndex based on where flick will end up\n  let index = this.dragEndRestingSelect();\n\n  if ( freeScroll && !this.isWrapping ) {\n    // if free-scroll & not wrap around\n    // do not free-scroll if going outside of bounding slides\n    // so bounding slides can attract slider, and keep it in bounds\n    let restingX = this.getRestingPosition();\n    this.isFreeScrolling = -restingX > this.slides[0].target &&\n      -restingX < this.getLastSlide().target;\n  } else if ( !freeScroll && index === this.selectedIndex ) {\n    // boost selection if selected index has not changed\n    index += this.dragEndBoostSelect();\n  }\n  delete this.previousDragX;\n  // apply selection\n  // HACK, set flag so dragging stays in correct direction\n  this.isDragSelect = this.isWrapping;\n  this.select( index );\n  delete this.isDragSelect;\n};\n\nproto.dragEndRestingSelect = function() {\n  let restingX = this.getRestingPosition();\n  // how far away from selected slide\n  let distance = Math.abs( this.getSlideDistance( -restingX, this.selectedIndex ) );\n  // get closet resting going up and going down\n  let positiveResting = this._getClosestResting( restingX, distance, 1 );\n  let negativeResting = this._getClosestResting( restingX, distance, -1 );\n  // use closer resting for wrap-around\n  return positiveResting.distance < negativeResting.distance ?\n    positiveResting.index : negativeResting.index;\n};\n\n/**\n * given resting X and distance to selected cell\n * get the distance and index of the closest cell\n * @param {Number} restingX - estimated post-flick resting position\n * @param {Number} distance - distance to selected cell\n * @param {Integer} increment - +1 or -1, going up or down\n * @returns {Object} - { distance: {Number}, index: {Integer} }\n */\nproto._getClosestResting = function( restingX, distance, increment ) {\n  let index = this.selectedIndex;\n  let minDistance = Infinity;\n  let condition = this.options.contain && !this.isWrapping ?\n    // if containing, keep going if distance is equal to minDistance\n    ( dist, minDist ) => dist <= minDist :\n    ( dist, minDist ) => dist < minDist;\n\n  while ( condition( distance, minDistance ) ) {\n    // measure distance to next cell\n    index += increment;\n    minDistance = distance;\n    distance = this.getSlideDistance( -restingX, index );\n    if ( distance === null ) break;\n\n    distance = Math.abs( distance );\n  }\n  return {\n    distance: minDistance,\n    // selected was previous index\n    index: index - increment,\n  };\n};\n\n/**\n * measure distance between x and a slide target\n * @param {Number} x - horizontal position\n * @param {Integer} index - slide index\n * @returns {Number} - slide distance\n */\nproto.getSlideDistance = function( x, index ) {\n  let len = this.slides.length;\n  // wrap around if at least 2 slides\n  let isWrapAround = this.options.wrapAround && len > 1;\n  let slideIndex = isWrapAround ? utils.modulo( index, len ) : index;\n  let slide = this.slides[ slideIndex ];\n  if ( !slide ) return null;\n\n  // add distance for wrap-around slides\n  let wrap = isWrapAround ? this.slideableWidth * Math.floor( index/len ) : 0;\n  return x - ( slide.target + wrap );\n};\n\nproto.dragEndBoostSelect = function() {\n  // do not boost if no previousDragX or dragMoveTime\n  if ( this.previousDragX === undefined || !this.dragMoveTime ||\n    // or if drag was held for 100 ms\n    new Date() - this.dragMoveTime > 100 ) {\n    return 0;\n  }\n\n  let distance = this.getSlideDistance( -this.dragX, this.selectedIndex );\n  let delta = this.previousDragX - this.dragX;\n  if ( distance > 0 && delta > 0 ) {\n    // boost to next if moving towards the right, and positive velocity\n    return 1;\n  } else if ( distance < 0 && delta < 0 ) {\n    // boost to previous if moving towards the left, and negative velocity\n    return -1;\n  }\n  return 0;\n};\n\n// ----- scroll ----- //\n\nproto.onscroll = function() {\n  let scroll = getScrollPosition();\n  let scrollMoveX = this.pointerDownScroll.x - scroll.x;\n  let scrollMoveY = this.pointerDownScroll.y - scroll.y;\n  // cancel click/tap if scroll is too much\n  if ( Math.abs( scrollMoveX ) > 3 || Math.abs( scrollMoveY ) > 3 ) {\n    this.pointerDone();\n  }\n};\n\n// ----- utils ----- //\n\nfunction getScrollPosition() {\n  return {\n    x: window.pageXOffset,\n    y: window.pageYOffset,\n  };\n}\n\n// -----  ----- //\n\nreturn Flickity;\n\n} ) );\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}